<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>POB PIXI Tree</title>
        <script src="pixi.js"></script>
        <style>
            body {
                margin: 0;
                padding: 0;
                display: flex;
                justify-content: center;
                align-items: center;
                height: 100vh;
                background-color: #2d2d2d;
                color: white;
                font-family: Arial, sans-serif;
            }

            #loading-message {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                text-align: center;
            }

            #loading-message h1 {
                margin: 0;
                font-size: 2rem;
            }

            #loading-message p {
                margin-top: 0.5rem;
                font-size: 1rem;
            }

            canvas {
                display: block;
            }
        </style>
    </head>
    <body>
        <div id="loading-message">
            <h1>Loading...</h1>
            <p>Please wait while the assets are being loaded.</p>
        </div>
        <script type="module">
            import { decompress, compress } from "https://deno.land/x/zstd_web@0.2/zstd.js";

            function createShape(image, layer)
            {
                const texture =  PIXI.Texture.from(image);

                if (texture.source.viewDimension === "2d") {
                    return new PIXI.Sprite({
                        texture: texture
                    });
                }

                return new PIXI.Sprite2DArray({
                    texture: texture,
                    layerId: layer,
                });
            }

            function calcOrbitAngles(nodesInOrbit)
            {
                let orbitAngles = [];

                if (nodesInOrbit == 16) {
                    // Every 30 and 45 degrees, per https://github.com/grindinggear/skilltree-export/blob/3.17.0/README.md
                    orbitAngles = [ 0, 30, 45, 60, 90, 120, 135, 150, 180, 210, 225, 240, 270, 300, 315, 330 ];
                } else if (nodesInOrbit == 40) {
                    // Every 10 and 45 degrees
                    orbitAngles = [ 0, 10, 20, 30, 40, 45, 50, 60, 70, 80, 90, 100, 110, 120, 130, 135, 140, 150, 160, 170, 180, 190, 200, 210, 220, 225, 230, 240, 250, 260, 270, 280, 290, 300, 310, 315, 320, 330, 340, 350 ];
                } else {
                    // Uniformly spaced
                    for (let i = 0; i < nodesInOrbit; i++) {
                        orbitAngles.push(360 * i / nodesInOrbit);
                    }
                }

                for (let i = 0; i < orbitAngles.length; i++) {
                    orbitAngles[i] = orbitAngles[i] * (Math.PI / 180);
                }

                return orbitAngles;
            }

            function GetNodeTargetSize(node)
            {
                if (node.isAscendancyStart) {
                    return {
                        overlay: { width: 50, height: 50 },
                    }
                } else if (node.type == "Normal" && node.ascendancyName) {
                    return {
                        overlay: { width: 80, height: 80 },
                        width: 37, height: 37
                    }
                } else if (node.ascendancyName) {
                    return {
                        overlay: { width: 100, height: 100 },
                        width: 54, height: 54
                    }
                } else if (node.type == "Notable") {
                    return {
                        effect: { width: 380, height: 380 },
                        overlay: { width: 80, height: 80 },
                        width: 54, height: 54
                    }
                } else if (node.type == "AscendClassStart") {
                    return {
                        effect:  { width: 380, height: 380 },
                        overlay: { width: 48 * 0.5, height: 48 * 0.5 },
                        width: 32 * 0.5, height: 32 * 0.5
                    }
                } else if (node.type == "OnlyImage") {
                    return { width: 380, height: 380 }
                } else if (node.type == "Keystone") {
                    return {
                        effect:  { width: 380, height: 380 },
                        overlay: { width: 120, height: 120 },
                        width: 82, height: 82
                    }
                } else if (node.type == "Normal") {
                    return {
                        overlay: { width: 54, height: 54 },
                        width: 37, height: 37
                    }
                } else if (node.type == "Socket") {
                    return {
                        overlay: {width: 76, height: 76 },
                        width: 76, height: 76
                    }
                } else if (node.type == "ClassStart") {
                    return {
                        overlay: { width: 1, height: 1 },
                        width: 37, height: 37
                    }
                } else {
                    return { width: 0, height: 0 };
                }
            }

            function calculateColorHex(percentage) {
                // Calculate the value for each RGB channel
                let value = Math.round(255 * (1 - (percentage / 100)));
                
                // Convert to hexadecimal and pad it to 2 digits
                let hexValue = value.toString(16).padStart(2, '0');
                
                // Return the final color in hex format
                return `#${hexValue}${hexValue}${hexValue}`;
            }


            async function  loadAndDecompressZstd(url) {
                const response = await fetch(url);
                const compressedData = new Uint8Array(await response.arrayBuffer());
                // Decompress the data
                const decompressedData = decompress(compressedData);
                return decompressedData.buffer;
            }

            async function loadTreeJSON(url) {
                const response = await fetch(url);
                return response.json();
            }

            const zstdDDSExtension = {
                extension: {
                    type: PIXI.ExtensionType.LoadParser,
                    priority: PIXI.LoaderParserPriority.Hight,
                    name: 'zstd-dds',
                },
                name: 'zstd-dds',
                test: (url) => PIXI.checkExtension(url, ['.zst']),
                load: async (url, loader, resource) => {
                    const supportedTextures = await PIXI.getSupportedTextureFormats();
                    const decompressedData = await loadAndDecompressZstd(url);
                    const textureOptions = PIXI.parseDDS(decompressedData, supportedTextures);
                    const compressedTextureSource = new PIXI.CompressedSource(textureOptions);
                    return PIXI.createTexture(compressedTextureSource, loader, url);
                },
                unload: (texture) => {
                    if (Array.isArray(texture)) {
                        texture.forEach((tex) => {
                            tex.destroy(true);
                        });
                    }
                    texture.destroy(true);
                },
            };

            function createOrGetTheMask(connector, texture, applyTexture)
            {
                // const mask = new PIXI.Graphics();
                // mask.setStrokeStyle({ width: 50, color: 0xFF0000, alpha: 1});
                // mask.arc(connector.x, connector.y, connector.r, connector.a1, connector.a2, false);
                // mask.stroke()

                const radious = connector.r;
                const innerRadious =  radious - 8;
                const outerRadious =  radious + 10;
                const startRad = connector.a2;
                const endRad = connector.a1;
                const x = connector.x;
                const y = connector.y;

                const vertices = [];
                const uvs = [];
                const indices = [];

                // generate arc points
                const uvRotationOffset = -Math.PI; // Shift UVs by -90Â°
                const segments = 30;
                for (let i = 0; i <= segments; i++) {
                    const angle = startRad + (endRad - startRad) * (i / segments);
                    const cosA = Math.cos(angle);
                    const sinA = Math.sin(angle);

                    // outer Ring Vertex
                    const outerX = x + outerRadious * cosA;
                    const outerY = y + outerRadious * sinA;
                    vertices.push(outerX, outerY);

                    // inner Ring Vertex
                    const innerX = x + innerRadious * cosA;
                    const innerY = y + innerRadious * sinA;
                    vertices.push(innerX, innerY);

                    // UVs
                    // ðŸŽ¯ Compute UV mapping for Outer Radius
                    const uvX_outer = 1 + cosA;
                    const uvY_outer = 1 + sinA;
                    uvs.push(uvX_outer, uvY_outer);

                    // ðŸŽ¯ Compute UV mapping for Inner Radius
                    const uvX_inner = 1 + ((innerRadious * cosA) / outerRadious);
                    const uvY_inner = 1 + (innerRadious * sinA) / outerRadious;
                    uvs.push(uvX_inner, uvY_inner);

                    // indices
                    if (i > 0) {
                        const p1 = (i - 1) * 2;
                        const p2 = (i - 1) * 2 + 1;
                        const p3 = i * 2;
                        const p4 = i * 2 + 1;

                        indices.push(p1, p2, p3); // First triangle
                        indices.push(p2, p4, p3); // Second triangle
                    }
                }
                const arcMesh = new PIXI.MeshSimple({
                    vertices: vertices,
                    uvs: uvs,
                    indices: indices,
                    texture: applyTexture ? texture : PIXI.Texture.WHITE,
                });

                //arcMesh.anchor.set(1);
                // arcMesh.position.set(connector.x, connector.y);

                return arcMesh;

                //const masktexture = PIXI.RenderTexture.create({ width: connector.r * 2, height: connector.r  * 2 });
                //app.renderer.render({container:mask, target: masktexture});
                
                // const maskSprite = new PIXI.Sprite(masktexture);
                // maskSprite.anchor.set(0.5);
                // maskSprite.position.set(connector.x, connector.y);
                // return mask;
            }

            try {
                PIXI.extensions.add(PIXI.loadDDS, PIXI.loadKTX , PIXI.detectCompressed, PIXI.resolveCompressedTextureUrl, zstdDDSExtension);
                const app = new PIXI.Application();
                await app.init({
                    resizeTo: window,
                    antialias: true,
                    useBackBuffer: true,
                    preference: 'webgpu',
                });

                // Hide the PixiJS canvas until loading is done
                app.canvas.style.display = 'none';
                
                // load tree.json file
                const scaleImage = 2;
                const ddsIconInfo = {};
                const assetsInfo = {};
                const basePath = 'https://raw.githubusercontent.com/PathOfBuildingCommunity/PathOfBuilding-PoE2/refs/heads/dev/src/TreeData/0_1/';
                const assetsToLoad = [];
                const treeInfo = await loadTreeJSON(basePath + 'tree.json');
                Object.entries(treeInfo.ddsCoords).forEach(([key, value]) => {
                    assetsToLoad.push(basePath + key);

                    Object.entries(value).forEach(([key2, value2]) => {
                        ddsIconInfo[key2] = {
                            texturePath: basePath + key,
                            layer: value2 - 1
                        };
                    });
                });

                Object.entries(treeInfo.assets).forEach(([key, value]) => {
                    assetsToLoad.push(basePath + value[0]);
                    assetsInfo[key] = {
                        texturePath: basePath + value[0]
                    };
                });

                // calculate orbits per skill
                treeInfo.orbitAnglesByOrbit = [];
                treeInfo.constants.skillsPerOrbit.forEach((value) => {
                    treeInfo.orbitAnglesByOrbit.push(calcOrbitAngles(value));
                });

                treeInfo.connectors = [];
                // calculate data of nodes
                Object.entries(treeInfo.nodes).forEach(([key,node]) => {
                    // calculate the position of the node base on the group
                    const group = treeInfo.groups[node.group - 1];
                    if (group == null) {
                        console.log('Group not found for node', node);
                        return;
                    }

                    // set the type
                    if (node.classesStart) {
                        node.type = "ClassStart";
                    } else if (node.isAscendancyStart) {
                        node.type = "AscendClassStart";
                    } else if (node.isOnlyImage) {
                        node.type = "OnlyImage";
                    } else if (node.ascendancyName && node.isNotable) {
                        node.type = "Notable";
                        node.overlay = {
                            unalloc: "AscendancyFrameLargeNormal",
                            alloc: "AscendancyFrameLargeAllocated",
                            path: "AscendancyFrameLargeCanAllocate",
                        };
                    } else if (node.ascendancyName) {
                        node.type = "Normal";
                        node.overlay = {
                            unalloc: "AscendancyFrameSmallNormal",
                            alloc: "AscendancyFrameSmallAllocated",
                            path: "AscendancyFrameSmallCanAllocate",
                        };
                    } else if (node.isJewelSocket) {
                        node.type = "Socket";
                        node.overlay = {
                            unalloc: "JewelFrameUnallocated",
                            alloc: "JewelFrameAllocated",
                            path: "JewelFrameCanAllocate",
                        };
                    } else if (node.isKeystone) {
                        node.type = "Keystone";
                        node.overlay = {
                            unalloc: "KeystoneFrameUnallocated",
                            alloc: "KeystoneFrameAllocated",
                            path: "KeystoneFrameCanAllocate",
                        };
                    } else if (node.isNotable) {
                        node.type = "Notable";
                        node.overlay = {
                            unalloc: "NotableFrameUnallocated",
                            alloc: "NotableFrameAllocated",
                            path: "NotableFrameCanAllocate",
                        };
                    } else {
                        node.type = "Normal";
                        node.overlay = {
                            unalloc: "PSSkillFrame",
                            alloc: "PSSkillFrameActive",
                            path: "PSSkillFrameHighlighted",
                        };
                    }

                    node.angle =  treeInfo.orbitAnglesByOrbit[node.orbit][node.orbitIndex];
                    let orbitRadious = treeInfo.constants.orbitRadii[node.orbit];
                    node.x = group.x + Math.sin(node.angle) * orbitRadious;
                    node.y = group.y - Math.cos(node.angle) * orbitRadious;
                });

                // calculate connectors
                Object.entries(treeInfo.nodes).forEach(([key,node]) => {
                    if (!node.connections || node.connections.length == 0) {
                        return;
                    }

                    for (let con of node.connections) {
                        let target = treeInfo.nodes[con.id];
                        if (!target) {
                            console.log('Target not found for node', node);
                            continue;
                        }

                        if (node.type == "OnlyImage" || target.type == "OnlyImage") {
                            continue;
                        }

                        if (node.ascendancyName != target.ascendancyName) {
                            continue;
                        }

                        if (node.skill == target.skill) {
                            continue;
                        }

                        if (node.classesStart || target.classesStart) {
                            continue;
                        }

                        if (con.orbit != 0 && treeInfo.constants.orbitRadii[Math.abs(con.orbit)]) {
                            // if (node.skill != 10364) {
                            //     continue;
                            // }
                            let orbit = Math.abs(con.orbit);
                            let r = treeInfo.constants.orbitRadii[orbit];

                            let dx = target.x - node.x;
                            let dy = target.y - node.y;
                            let distance = Math.sqrt(dx * dx + dy * dy);

                            if (distance < 2 * r) {
                                let perp = Math.sqrt(r * r - (distance * distance) / 4) * Math.sign(con.orbit);
                                let cx = node.x + dx / 2 + perp * (dy / distance);
                                let cy = node.y + dy / 2 - perp * (dx / distance);

                                let angle1 = Math.atan2(node.y - cy, node.x - cx);
                                let angle2 = Math.atan2(target.y - cy, target.x - cx);

                                let startAngle = angle1 < angle2 ? angle1 : angle2;
                                let endAngle = angle1 < angle2 ? angle2 : angle1;

                                const diff = endAngle - startAngle;
                                if (diff >= Math.PI) {
                                    const c = 2 * Math.PI - diff;
                                    startAngle = endAngle;
                                    endAngle = startAngle + c;
                                }

                                // startAngle -= Math.PI / 2;
                                // endAngle -= Math.PI / 2;

                                let angle = endAngle - startAngle;
                                const arcsNeed = Math.ceil(angle / (Math.PI / 2));
                                const initialRotation = Math.PI / 2 + startAngle;
                                for (let i = 0; i < arcsNeed; i++) {
                                    let connector = { 
                                        type: "Orbit" + orbit, 
                                        x: cx, 
                                        y: cy,
                                        rotation: angle + initialRotation,
                                        a1: startAngle,
                                        a2: endAngle,
                                        r: r
                                    };
                                    treeInfo.connectors.push(connector);

                                    if (angle < Math.PI / 2) {
                                        continue;
                                    }
                                    angle -= Math.PI / 2;
                                }
                                continue;
                            }
                            
                        } else if (node.group == target.group && node.orbit == target.orbit && con.orbit == 0) {
                            let startAngle = node.angle < target.angle ? node.angle : target.angle;
                            let endAngle = node.angle < target.angle ? target.angle : node.angle;

                            const diff = endAngle - startAngle;
                            if (diff >= Math.PI) {
                                const c = 2 * Math.PI - diff;
                                startAngle = endAngle;
                                endAngle = startAngle + c;
                            }

                            startAngle -= Math.PI / 2;
                            endAngle -= Math.PI / 2;

                            let cx = treeInfo.groups[node.group - 1].x;
                            let cy = treeInfo.groups[node.group - 1].y;
                            let angle = endAngle - startAngle;
                            const arcsNeed = Math.ceil(angle / (Math.PI / 2));
                            const initialRotation = Math.PI / 2 + startAngle;
                            for (let i = 0; i < arcsNeed; i++) {
                                let connector = { 
                                    type: "Orbit" + node.orbit, 
                                    x: cx, 
                                    y: cy,
                                    rotation: angle + initialRotation,
                                    a1: startAngle,
                                    a2: endAngle,
                                    r: treeInfo.constants.orbitRadii[node.orbit]
                                };
                                treeInfo.connectors.push(connector);

                                if (angle < Math.PI / 2) {
                                    continue;
                                }
                                angle -= Math.PI / 2;
                            }
                            continue;
                        }

                        let start = { x: node.x, y: node.y };
                        let end = { x: target.x, y: target.y };
                        let distance = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
                        let angle = Math.atan2(end.y - start.y, end.x - start.x);
                        let control = { x: start.x + distance / 2 * Math.cos(angle), y: start.y + distance / 2 * Math.sin(angle) };
                        treeInfo.connectors.push({ type: "LineConnector", x: control.x, y: control.y, rotation: angle, width: distance });
                    }
                })

                // load the json file
                await PIXI.Assets.load(assetsToLoad);

                // Hide the loading message
                document.getElementById('loading-message').style.display = 'none';

                // Show the PixiJS canvas
                app.canvas.style.display = 'block';

                // load center background
                const bgAsset = ddsIconInfo['Background2'];
                const bg = PIXI.Sprite.from(bgAsset.texturePath);
                // bg.position.set(app.screen.width / 2, app.screen.height / 2);
                bg.width = app.screen.width;
                bg.height = app.screen.height;
                
                app.stage.addChild(bg);

                // Viewport
                const viewport =  new PIXI.Container();
                app.stage.addChild(viewport);

                const bgContainer = new PIXI.Container();
                viewport.addChild(bgContainer);

                const arcContainer = new PIXI.Container();
                viewport.addChild(arcContainer);

                const linesContainer = new PIXI.Container();
                viewport.addChild(linesContainer);

                const nodesContainer = new PIXI.Container();
                viewport.addChild(nodesContainer);

                let assetOrbit2 = PIXI.Texture.from(assetsInfo["Orbit2Normal"].texturePath);
                assetOrbit2.source.style.maxAnisotropy = 16;
                assetOrbit2.source.autoGenerateMipmaps = true;
                let demoArc = createOrGetTheMask({ x: 0, y: 0, r: 162, a1: 250 * (Math.PI / 180), a2: 270 * (Math.PI / 180) }, assetOrbit2, true);
                let demo2Arc = createOrGetTheMask({ x: 0, y: 0, r: 162, a1: 270 * (Math.PI / 180), a2: 360 * (Math.PI / 180) }, assetOrbit2, true);

                let spriteArc = new PIXI.Sprite(assetOrbit2);
                spriteArc.anchor.set(1);
                spriteArc.position.set(100, 0);
                arcContainer.addChild(spriteArc);
                //demoArc.setStrokeStyle({ width: 50, color: 0xFF0000, alpha: 1})
                //demoArc.arc(0, 0, 500, 0, Math.PI / 2);
                //demoArc.rect(0, 0, 1000, 1000);
                //demoArc.stroke();
                arcContainer.addChild(demoArc);
                arcContainer.addChild(demo2Arc);

                // load the class
                let classAsset =  ddsIconInfo['ClassesMonk'];
                const classMesh = createShape(classAsset.texturePath, classAsset.layer);
                classMesh.anchor.set(0.5);
                classMesh.position.set(0, 0);
                classMesh.width = 1500 * scaleImage;
                classMesh.height = 1500 * scaleImage;
                bgContainer.addChild(classMesh);

                // Load the center activate
                let treeCenterActive = ddsIconInfo['BGTreeActive'];
                const treeCenterActiveMesh = createShape(treeCenterActive.texturePath, treeCenterActive.layer);
                treeCenterActiveMesh.anchor.set(0.5);
                treeCenterActiveMesh.position.set(0, 0);
                treeCenterActiveMesh.width = 2000 * scaleImage;
                treeCenterActiveMesh.height = 2000 * scaleImage;
                bgContainer.addChild(treeCenterActiveMesh);

                // Load the center tree
                let treeCenter = ddsIconInfo['BGTree'];
                const treeCenterMesh = createShape(treeCenter.texturePath, treeCenter.layer);
                treeCenterMesh.anchor.set(0.5);
                treeCenterMesh.position.set(0, 0);
                treeCenterMesh.width = 2000 * scaleImage;
                treeCenterMesh.height = 2000 * scaleImage;
                bgContainer.addChild(treeCenterMesh);

                // draw connectors
                treeInfo.connectors.forEach((connector) => {
                    const asset =  connector.type + (connector.alloc ? "Active" : "Normal");
                    const connectorAsset = assetsInfo[asset];
                    if (connectorAsset.TextCache == null) {
                        connectorAsset.TextCache = PIXI.Texture.from(connectorAsset.texturePath);
                        connectorAsset.TextCache.source.style.maxAnisotropy = 16;
                        connectorAsset.TextCache.source.autoGenerateMipmaps = true;
                    }

                    const connectorMesh = PIXI.Sprite.from(connectorAsset.TextCache);
                    let tmpContainer = linesContainer;
                    if (connector.type == "LineConnector") {
                        connectorMesh.anchor.set(0.5);
                        tmpContainer = linesContainer;
                    } else {
                        // tmpContainer = arcContainer;
                        // create the arc mask based on a1 and a2
                        const mask = createOrGetTheMask(connector, connectorAsset.TextCache);
                        arcContainer.addChild(mask);
                        // connectorMesh.mask = mask;
                        connectorMesh.anchor.set(1);
                        return;
                    }
                    connectorMesh.position.set(connector.x, connector.y);
                    connectorMesh.rotation = connector.rotation;
                    if (connector.width) {
                        connectorMesh.width = connector.width;
                    }
                    if (connector.height) {
                        connectorMesh.height = connector.height;
                    }
                    tmpContainer.addChild(connectorMesh);
                });

                // draw nodes
                Object.entries(treeInfo.nodes).forEach(([key,node]) => {
                    if (node.type == "ClassStart") {
                        return;
                    }
                    let sizes = GetNodeTargetSize(node);
                    
                    if (node.activeEffectImage) {
                        const effectAsset = ddsIconInfo[node.activeEffectImage];
                        const effectMesh = createShape(effectAsset.texturePath, effectAsset.layer);
                        const dimensions = (node.isOnlyImage || !sizes.effect) ? sizes : sizes.effect;
                        effectMesh.anchor.set(0.5);
                        effectMesh.position.set(node.x, node.y);
                        effectMesh.tint = calculateColorHex(70); // 30% luminosity
                        effectMesh.width = dimensions.width * scaleImage;
                        effectMesh.height = dimensions.height * scaleImage;
                        bgContainer.addChild(effectMesh);
                    }

                    if (node.isOnlyImage) {
                        return;
                    }

                    if (node.type != "Socket") {
                        const nodeAsset = ddsIconInfo[node.icon];
                        if (!nodeAsset) {
                            console.log('Asset not found for node', node);
                            return;
                        }
                        const nodeMesh = createShape(nodeAsset.texturePath, nodeAsset.layer);
                        nodeMesh.tint = node.alloc ? calculateColorHex(0) : calculateColorHex(20); // 50% luminosity
                        nodeMesh.anchor.set(0.5);
                        nodeMesh.position.set(node.x, node.y);

                        nodeMesh.width = sizes.width * scaleImage;
                        nodeMesh.height = sizes.height * scaleImage;
                        nodesContainer.addChild(nodeMesh);
                    }

                    if (node.overlay) {
                        const state = node.alloc ? node.overlay.alloc : node.overlay.unalloc;
                        const overlayAsset = ddsIconInfo[state];
                        const overlayMesh = createShape(overlayAsset.texturePath, overlayAsset.layer);
                        overlayMesh.anchor.set(0.5);
                        overlayMesh.position.set(node.x, node.y);
                        overlayMesh.width = sizes.overlay.width * scaleImage;
                        overlayMesh.height = sizes.overlay.height * scaleImage;
                        nodesContainer.addChild(overlayMesh);
                    }
                });

                // Event handler
                let zoomFactor = 0.03;
                viewport.x = app.screen.width / 2;
                viewport.y = app.screen.height / 2;
                viewport.scale.set(zoomFactor);

                let isDragging = false;
                let dragStart = { x:0, y:0 };
                let containerStart = { x:0, y:0 };

                app.stage.interactive = true;
                app.stage.hitArea = app.screen;

                app.stage.on("pointerdown", (event) => {
                    isDragging = true;
                    dragStart = { x: event.global.x, y: event.global.y };
                    containerStart = { x: viewport.x, y: viewport.y };
                });

                app.stage.on("pointerup", () => {
                    isDragging = false;
                });

                app.stage.on("pointerupoutside", () => {
                    isDragging = false;
                });

                app.stage.on("pointermove", (event) => {
                    if (isDragging) {
                        const dx = event.global.x - dragStart.x;
                        const dy = event.global.y - dragStart.y;
                        viewport.x = containerStart.x + dx;
                        viewport.y = containerStart.y + dy;
                    }
                });

                app.stage.on("wheel", (event) => {
                    event.preventDefault();
                    const zoomAmount = 0.08; // Adjust zoom speed
                    const oldZoom = zoomFactor;

                    if (event.deltaY < 0) {
                        zoomFactor = Math.min(zoomFactor + zoomAmount, 1);
                    } else {
                        zoomFactor = Math.max(zoomFactor - zoomAmount, 0.03);
                    }
                    
                    const mousePos =  event.global;
                    const containerMouseX = (mousePos.x - viewport.x) / oldZoom;
                    const containerMouseY = (mousePos.y - viewport.y) / oldZoom;

                    const newViewportX = mousePos.x - containerMouseX * zoomFactor;
                    const newViewportY = mousePos.y - containerMouseY * zoomFactor;

                    viewport.x = newViewportX;
                    viewport.y = newViewportY;

                    viewport.scale.set(zoomFactor);
                });

                let elapsed = 0.0;

                app.ticker.add((ticker) => {
                    elapsed += ticker.deltaTime;
                });

                document.body.appendChild(app.canvas);
            } catch (error) {
                document.getElementById('loading-message').innerText = 'An error occurred while loading the assets.\n' + error;  
            }
        </script>
    </body>
</html>